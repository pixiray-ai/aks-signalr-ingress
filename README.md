# Sample SignalR Chat for AKS and NGINX Ingress Debugging

Repository Explaining Basic Concepts on Signal-R Ingress for AKS with NGINX.
Please note that this does not explain how to scale Signal-R services on AKS. 
The Basic concept is to have one service and one pod. 
We can add that feature and many more later, if there is a demand for this type of scenario.

About the Project:
---
- ASP.NET CORE 7.0.300-preview
- SIGNALR 6.0.1
- Razorpages
- Ubuntu WSL2 22.04.2

Features:
---
- Serilog Logger for SignalR in Console of the POD
- SignalR Chat for Debugging Purposes

- Webclient Index.cshtml & chat.js
  - Running Port 80
- Signal ChatHub 
  - Running Port 5000
- Read the Logs from Docker Container
  - 'docker logs --since=1h CONTAINERID'

# Prerequisites
- Basic Understanding of [Kubernetes networking](https://kubernetes.io/docs/concepts/services-networking/) and [Nginx Ingress](https://docs.nginx.com/nginx-ingress-controller/intro/overview/) 
- Azure Subscription
- Basic understanding of Azure (recommended)

# Content

You can skip Chapter 1 if you are already familiar with SignalR.

## Chapter 1 - What Signalr-R really is
### Introduction

In today's digital landscape, real-time communication has become increasingly crucial for developers. Whether you're building a chat application, collaborative editing tool, or a live dashboard, the ability to instantly exchange information between clients and servers is paramount. This is where SignalR comes into play. In this blog post, we will explore the fundamentals of SignalR and how it empowers developers to create interactive and responsive applications.

### What is SignalR?

SignalR is an open-source real-time web application framework developed by Microsoft. It simplifies the process of adding real-time functionality to applications by providing an abstraction layer over various communication technologies. With SignalR, developers can build applications that enable instant bi-directional communication between clients (such as web browsers, apps, ...) and servers.

### Key Features and Benefits:

1. Real-Time Communication: SignalR facilitates real-time communication by establishing persistent connections between clients and servers. This enables instant data transmission, eliminating the need for clients to manually refresh the page or continuously poll the server for updates.

2. Broad Client Support: SignalR supports a wide range of client platforms, including web browsers (JavaScript), mobile devices (iOS, Android), desktop applications (Windows, macOS), and even IoT devices. This versatility allows developers to create interactive experiences across multiple platforms with ease.

3. Scalability: SignalR is designed to scale effortlessly. It supports various hosting options, such as self-hosting within your application or using Microsoft Azure's cloud infrastructure. SignalR automatically manages connections, load balancing, and server affinity, ensuring seamless performance even with a large number of clients.

4. Built-in Connection Management: SignalR abstracts away the complexities of connection management, including negotiation, reconnection, and error handling. It handles connectivity issues transparently, enabling automatic reconnection in case of network disruptions and other failure scenarios.

5. Flexible Communication Patterns: SignalR supports multiple communication patterns, including one-to-one, one-to-many, and broadcasting. This flexibility allows developers to tailor their applications to specific use cases, such as private messaging, real-time notifications, or collaborative editing.

### How SignalR Works:
SignalR leverages various underlying transport technologies to establish real-time connections. It uses WebSockets as the primary transport protocol, which provides a full-duplex communication channel over a single TCP connection, enabling efficient real-time data transfer. However, if WebSockets are not supported by the client or server, SignalR gracefully falls back to alternative transport mechanisms, such as Server-Sent Events (SSE) or Long Polling.

SignalR employs a hub-based architecture, where developers define server-side hub classes responsible for handling incoming client requests and broadcasting messages to connected clients. Clients can invoke server-side methods through hub proxies, which are automatically generated by SignalR. This two-way communication model ensures a smooth and seamless experience for developers when building real-time applications.

TODO: Explain necessary basics ...

### Conclusion:
SignalR empowers developers to create highly interactive and responsive applications by providing a simple yet powerful framework for real-time communication. Its broad client support, scalability, and built-in connection management make it a popular choice for a wide range of applications. By leveraging SignalR, developers can focus on delivering engaging user experiences while leaving the complexities of real-time communication to the framework. So, whether you're building a collaborative application or enhancing the responsiveness of an existing project, SignalR is a valuable tool in your development arsenal.

### Summarization by Microsoft AspNet Core Team

> - Framework for duplex RPC & streaming between client and server
> - Provides "real-time" messaging & server-push functionality  l
> - Protocols for transport and messaging layers allow broad reach
> - Server support for client addressing & grouping, e.g.:
>     - Send to all clients
>     - Send to this one client (connection or user)
>     - Send to this group of clients

### Supporting multiple clients
> - SignalR supports different client types
> - HTTP transport
>    - [WebSockets](https://websockets.spec.whatwg.org/)
>    - ServerSentEvents
>    - [Long Polling (IETF RFC:6202)](https://datatracker.ietf.org/doc/html/rfc6202#section-2.1)

- [David Fowler]() and [Demian Edwards]() at [NDC London January 2020 - SignalR Deep Dive: Building Servers - David Fowler & Damian Edwards](https://www.youtube.com/watch?v=iL9nLAjCPtM)

List of Signalr clients and server implementations:

| Name and Repo        | Publisher         | Microsoft Supported        | Microsoft Contributed   |
| ------------- |:-------------:|:-------------:| -----:|
| [JavaScript](https://learn.microsoft.com/en-us/aspnet/core/signalr/javascript-client?view=aspnetcore-7.0&tabs=visual-studio)      | Microsoft | YES | YES |
| [.NET](https://learn.microsoft.com/en-us/aspnet/core/signalr/dotnet-client?view=aspnetcore-7.0&tabs=visual-studio)      | Micorsoft      |   YES |YES |
| [Java](https://learn.microsoft.com/en-us/aspnet/core/signalr/java-client?view=aspnetcore-7.0) | Microsoft     |    YES |YES |
| [C++](https://github.com/aspnet/SignalR-Client-Cpp)      | Microsoft      |   NO |YES |
| [Swift](https://github.com/moozzyk/SignalR-Client-Swift)      | moozzyk      |   NO |YES |
| [GO](https://github.com/philippseith/signalr)      | philippseith      |   NO |YES |

As of 12th of June 2023,
Microsoft Supported accoding to [docs.microsoft.com](https://learn.microsoft.com/de-de/aspnet/core/signalr/supported-platforms?view=aspnetcore-7.0)

### More about Signal-R:

This client components are implemented by two protocol layers.
- [Transport protocol](https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/TransportProtocols.md) provides flexibility for connection types, e.G. HTTP vs TCP/IP
- [Hub protocol](https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md) provides flexibility for message formats, e.g. JSON vs. MessagePack

### Needed Background Knowledge

TODO: Explain needed configuration ...

- [Scale Signalr documentation](https://github.com/dotnet/AspNetCore.Docs/blob/main/aspnetcore/signalr/scale.md)

- [David Fowler]() and [Demian Edwards]() at [NDC London January 2020 - SignalR Deep Dive: Building Servers - David Fowler & Damian Edwards](https://www.youtube.com/watch?v=iL9nLAjCPtM)
- [David Fowler]() and [Demian Edwards]() at [ Build 2018 - Meet the new stack for real-time web communication: ASP.NET Core SignalR](https://www.youtube.com/watch?v=Lws0zOaseIM)

- [Official Microsoft Docs about SignalR](https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-7.0)

Changes in aspnet core SignalR with previous versions
- No more jQuery dependency
- No more auto-reconnect with message replay
- No more hub state
- No more multi-hub endpoints
- No more single-model scale-out
- No more multi server ping-pong (nor requires sticky sessions)

## Chapter 2 - Hosting SignalR in AKS

### Pre-Requisites
This sample and tutorial expects that you have a kubernetes cluster in microsoft azure that supports Azure CNI.
- You have installed the latest version of Azure CNI.
- You have installed kubectl
- Your desired Ingress, Kubernetes Cluster and Helm are compatible. 

Make sure you have a public LB your DNS can point to. 

Install a LB for incomming traffic. There are two ways how you can achieve this. The simplest way to allocate a static Public Ip.

We want to find the resource group that holds the virtual machine agent-pool for your aks cluster.
you can use the following command in azure cli to achieve that.

```console
az group list
```

Now we want to create the public static ip for loadbalancing to the cluster.

```console
az network public-ip create --resource-group YOURAGENTPOOLRG --name YOURDESIREDIPNAME --sku Standard --allocation-method static --query publicIp.ipAddress -o tsv
```

OPTIONAL

if you are using DNS Zone in Azure you can now point to this IP address.

```console
az network dns record-set a add-record --resource-group YOURRGNAME --zone-name YOURDOMAIN.COM --record-set-name YOURDESIREDCNAME --ipv4-address 000.000.000.000
```
Make sure to use IP from previous call.

# Ingress Overview

## Scope


## Desired Ingress

Implementation:

### Service bind to IP

1. Create Namespace in AKS Cluster

2. Create a pod running

3. Bind the pod to a LB

DONE

### Implementation with NGINX INGRESS

1. Create a Namespace in AKS Cluser

get namespaces in the cluster

```console
kubectl get namespace
```

create a new namespace 

```console
kubectl create namespace YOUR_NAMESPACE
```

get namespaces in the cluster

```console
kubectl get namespace
```

>Note: Make sure you have removed any previous installations of NGINX see this guide: TODO

2. Install NGINX Ingress Controller with the following - configuration

>NOTE: Make sure to replace with IP from step 1. 
And set the Namespace to YOUR_NAMESPACE you just created in kubernetes.

```console
helm install ingress-nginx ingress-nginx/ingress-nginx \
    --namespace YOUR_NAMESPACE \ 
    --set controller.replicaCount=2 \
    --set controller.nodeSelector."beta\.kubernetes\.io/os"=linux \
    --set defaultBackend.nodeSelector."beta\.kubernetes\.io/os"=linux \
    --set controller.service.externalTrafficPolicy=Local \
    --set controller.service.loadBalancerIP="000.000.000.000" 
```

Check the helm install
```console
helm list -n YOUR_NAMESPACE
```

Check the installed Ingress

```console
kubectl get svc -n YOUR_NAMESPACE
```

You should now see, something like this. 

|NAME|                                 TYPE|           CLUSTER-IP|     EXTERNAL-IP|    PORT(S)|                      AGE|
| ------------- |:-------------:|:-------------:| -----:|-----:|-----:|
|ingress-nginx-controller|             LoadBalancer|   10.0.117.204|   52.142.199.24|   80:30869/TCP,443:32592/TCP|   6h39m|

3. Create Secrets for TLS

TODO: Create Tutorial for creation of Secrets 
See [reference documentation](https://kubernetes.github.io/ingress-nginx/user-guide/tls/) for more information. 

>NOTE: It is a small line to apply but a lot of work to do to get there.

```console
kubectl create secret tls goddess-secret --key keyfile.key --cert cert_reverse.pem
```

4. Deploy pods

The YAML for the POD

```yaml
  GNU nano 6.2                                                           chat-app.yaml                                                                     apiVersion: apps/v1
kind: Deployment
metadata:
  name: chat
  labels:
    app: signalrchat
    group: testing
spec:
  replicas: 1
  selector:
    matchLabels:
      app: signalrchat
  template:
    metadata:
      labels:
        app: signalrchat
        group: testing
    spec:
      containers:
        - name: signalrchat
          image: pixiray.azurecr.io/signalrchat
          imagePullPolicy: Always
          ports:
            - name: web
              containerPort: 8080
            - name: websocket
              containerPort: 5000
          env:
          - name: "CORS_ORIGINS"
            value: "https://demo.pixiray.ninja;http://demo.pixiray.ninja"
         # - name: "KNOWN_PROXIES"
         #   value: "10.0.185.130"
```

- You will need both http/s domains listed. Please note this is due to the handshake of Signal-r client.
- please note the application will run without explicit proxy configuration

```console
kubectl apply -f chat-app.yaml -n YOUR_NAMESPACE
```
Make sure the deployment went well

```console
kubectl get pods -n YOUR_NAMESPACE
```

Select the pod that has been created and copy the name

```console
kubectl describe pod PASTE_POD_NAME_HERE -n YOUR_NAMESPACE
```

You can access the logs of the pod and therefor the signalr app at any time by using 

OPTIONAL AT THIS POINT

```console
kubectl logs PASTE_POD_NAME_HERE -n YOUR_NAMESPACE
```

5. Deploy the service 

```yaml
  # Default values for azure-vote-front.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
kind: Service
apiVersion: v1
metadata:
  name:  signalrchat-service
spec:
  selector:
    app:  signalrchat
  ports:
  - name:  web
    port:  8080
    targetPort:  80
  - name:  websocket
    port:  5000
    targetPort: 5000
  sessionAffinity: ClientIP
  type: ClusterIP
```
Check the service by using 

```console
kubectl get svc -n YOUR_NAMESPACE
```

6. Deploy INGRESS
```yaml
  GNU nano 6.2                                                            ingress.yaml                                                                     apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: test-ingress
  namespace: wolf
  annotations:
    nginx.ingress.kubernetes.io/use-regex: "true"
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, PATCH, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-headers: "Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,X-SignalR-User-Agent"
    nginx.ingress.kubernetes.io/cors-allow-credentials: "true"
    nginx.ingress.kubernetes.io/affinity: cookie
    nginx.ingress.kubernetes.io/affinity-mode: persistent
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
spec:
  tls:
    - hosts:
      - "yourdomain.com"
      secretName: changetoyoursecretvariable
  ingressClassName: nginx
  rules:
  - host: "subdomain.yourdomain.com"
    http:
      paths: /
        - pathType: Prefix
              backend:
                service:
                  name: signalrchat-service
                  port:
                    number: 80
```

```console
kubectl apply -f ingress.yaml -n YOUR_NAMESPACE
```

Check the just generated Ingress

```console
kubectl describe ing -n YOUR_NAMESPACE
```

Call the site via curl or browser.
Check the logs?

if err check the ingress logs

```console
kubectl get svc -n YOUR_NAMESPACE
```
copy the nginx service behind logs

```console
kubectl logs ingress-nginx-controller-55d445d69d-flxmb -n YOUR_NAMESPACE
```

```console
kubectl logs PASTE_POD_NAME_HERE -n YOUR_NAMESPACE
```

# Helpfull commands:

Find installed helm charts

```console
helm ls -A
```

Find stuff that is managed by helm
```console
kubectl get all --all-namespaces -l='app.kubernetes.io/managed-by=Helm'
```

k9s is always helpful ^_^

# Architecture and Scaling Considerations

At the core of the SignalR architecture lies the backend application server. This server acts as a central hub, facilitating real-time communication between clients and handling incoming client requests. The backend server is responsible for managing connections, broadcasting messages to clients, and executing server-side methods.

## Scaling Considerations
To ensure scalability, developers can leverage larger node types based on workload requirements. By utilizing nodes with increased memory or computing power, applications can accommodate a larger number of connected clients. However, scaling to multiple instances of the same pod to serve a larger user base requires a well-designed backend architecture capable of handling sticky sessions. That could be achieved via a backplate architecture with a redis cache. 

## Handling Socket Connection Issues
SignalR relies heavily on WebSockets as the primary transport protocol for efficient real-time data transfer. However, certain limitations need to be considered, especially when working with Windows clients. Windows client versions impose a constraint of only allowing 10 socket connections per developer client. This constraint poses challenges in efficiently handling a large number of concurrent clients, especially in Windows-based environments during development and developers should be aware that they use windows server instead to test multiple connection development and testing.

## Efficient Parallel Client Handling
Efficiency is a crucial aspect of the SignalR architecture, particularly when it comes to handling a high volume of concurrent clients. Developers must strive to handle as many clients in parallel as possible. This includes optimizing the processing and response times of server-side methods to minimize latency and ensure a smooth real-time experience for the clients. In some edge cases it might be benefitial to implement an own server and just use the available clients, but we would always recommend to use Kestrel as default. In order to scale out in the cloud we recommend the [Microsoft Azure Signalr Service](https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview) when needed. Since message payload, protocols and monitoring are a part of when to scale socket connections this is solution which can be applied easily to existing projects but is also to be considered a vendor lock to microsoft azure.     

## Payload Considerations
Another important factor in the scaling architecture is the payload utilized for data transmission. Developers must consider whether to use the JSON Message Format or employ binary packaging such as [MessagePack5](https://msgpack.org/index.html) for transmitting data efficiently. Choosing the appropriate payload format can significantly impact the overall performance and bandwidth utilization of the application.

## Conclusion:
SignalR offers a robust architecture that enables developers to implement real-time communication in web applications effectively. By utilizing a backend application server, developers can establish seamless connections between clients and servers. However, scaling and optimizing the performance of a SignalR application require careful consideration of various factors, including node types, handling socket connection limitations, efficient client handling, and payload considerations. By addressing these architectural aspects, developers can build scalable, efficient, and responsive applications that deliver exceptional real-time experiences to their users.

# References 

- [Kubernetes CheatSheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)
- [Document reverse proxy usage with SignalR #10827](https://github.com/dotnet/AspNetCore.Docs/issues/10827)

